# generated by fastapi-codegen:
#   filename:  /Users/nickfode/dev/work/flip/rag-chatbot/chatbot/codegen/tmp/api.yaml

from __future__ import annotations

from typing import Annotated, List, Literal, Optional
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field, constr

type AskAiTriggerStatus = Annotated[
    Literal['ACTIVE', 'INACTIVE'], Field(..., description='The status of the trigger.')
]


class TriggerFlipFlowActionData(BaseModel):
    action: Literal['TRIGGER_FLIP_FLOW'] = Field(
        ..., description='The type of action to perform.'
    )
    flow_id: UUID = Field(..., description='The ID of the Flip Flow to trigger.')
    message_id: UUID = Field(
        ..., description='The ID of the message to trigger the flow with.'
    )


type TriggerActionData = Annotated[
    TriggerFlipFlowActionData, Field(..., discriminator='action')
]


class TriggerAction(BaseModel):
    action: TriggerActionData


type UserGroupId = Annotated[
    UUID, Field(..., description='Unique identifier of a user group.')
]


type Locale = Annotated[
    constr(pattern=r'^[a-z]{2,4}(-[A-Z][a-z]{3})?(-([A-Z]{2}|[0-9]{3}))?$'),
    Field(
        ...,
        description='A locale representing a language and region.',
        examples=['en-GB'],
    ),
]


class ActionInformation(BaseModel):
    allowed: bool


type CreatedAt = Annotated[
    AwareDatetime,
    Field(..., description='The point in time at which this resource was created.'),
]


type UpdatedAt = Annotated[
    AwareDatetime,
    Field(
        ..., description='The point in time at which this resource was last updated.'
    ),
]


class OffsetPagination(BaseModel):
    page_number: int
    total_pages: int
    total_elements: int
    page_limit: int = Field(
        ...,
        description='The page_limit parameter value that was used to generate the response',
    )


type UserGroupAssignmentRuleConditionType = Annotated[
    Literal['ATTRIBUTE_ANY_OF'],
    Field(
        ...,
        description='The type of condition used in user group assignment rules.\nThis list of condition types will be extended in the future.\nPlease ensure your parser can handle unknown types in responses.',
    ),
]


class UserGroupAssignmentRuleAttributeValue(BaseModel):
    value: str


class GenerateAssignmentRulesRequest(BaseModel):
    prompt: constr(min_length=1, max_length=1000) = Field(
        ...,
        description='A natural language prompt describing the desired assignment rules.',
        examples=[
            'Assign all users from the Sales department to the Sales team with a Member role'
        ],
    )


type GenerateAssignmentRulesStatus = Annotated[
    Literal['SUCCESS', 'ERROR'],
    Field(..., description='The status of the assignment rules generation.'),
]


type RoleId = Annotated[UUID, Field(..., description='Unique identifier of a role.')]


type RoleTitle = Annotated[
    constr(max_length=120),
    Field(..., description='Title of the Role', examples=['System Owner']),
]


class RoleTitleTranslation(BaseModel):
    language: Locale
    text: RoleTitle


type RoleType = Annotated[
    Literal['PREDEFINED', 'CUSTOM'],
    Field(..., description='Distinguishes predefined and custom roles'),
]


type PredefinedRoleType = Annotated[
    Optional[
        Literal[
            'SYSTEM_OWNER',
            'SYSTEM_ADMIN',
            'USER_GROUP_ADMIN',
            'USER_GROUP_MEMBER',
            'USER_SELF',
            'CHANNEL_ADMIN',
            'CHANNEL_MANAGER',
            'CHANNEL_MEMBER',
            'CHANNEL_CONTRIBUTOR',
            'PAGE_VIEWER',
            'PAGE_EDITOR',
        ]
    ],
    Field(None, description='Identifier of a predefined role.'),
]


type PermissionsScope = Annotated[
    Literal['ORGANISATION', 'USER_GROUP', 'USER_SELF', 'CHANNEL', 'PAGE'],
    Field(
        ...,
        description='The scope describes the context in which a permission is valid.',
    ),
]


class RoleEditActions(ActionInformation):
    localizations: ActionInformation
    permissions: ActionInformation
    external_id: ActionInformation


class RoleActions(BaseModel):
    edit: RoleEditActions
    delete: ActionInformation
    reset: ActionInformation


class RoleReference(BaseModel):
    id: RoleId
    title: RoleTitleTranslation
    type: RoleType
    predefined_role_type: Optional[PredefinedRoleType] = None
    scope: PermissionsScope
    permission_count: int = Field(
        ...,
        description='The number of permissions configured for the role.',
        examples=[1],
    )
    actions: Optional[RoleActions] = None


type UserAttributeDefinitionId = UUID


type UserAttributeTitle = Annotated[
    constr(max_length=64),
    Field(
        ...,
        description='The display name of the attribute as displayed to end users.',
        examples=['Department'],
    ),
]


class UserAttributeTitleTranslation(BaseModel):
    language: Locale
    text: UserAttributeTitle


type UserAttributeTechnicalName = Annotated[
    constr(pattern=r'^[a-zA-Z0-9\-_.]+$', max_length=64),
    Field(
        ...,
        description='The technical name of the attribute. This is the attribute name that will be accepted and returned by API calls. Required to be unique. Must only contain alphanumeric characters and the characters `-`, `_`, `.`\n',
        examples=['department'],
    ),
]


type UserAttributeUserPermission = Annotated[
    Literal['VIEW', 'EDIT', 'HIDDEN'],
    Field(
        ...,
        description='The access level of the attribute. This determines if the attribute is visible to end users and whether they can edit it for themselves.\n"HIDDEN" attributes are only returned in User Admin APIs and User Self APIs, i.e. they can only be accessed by admins and the user themselves.\n',
    ),
]


type UserAttributeType = Annotated[
    Literal['TEXT', 'PHONE_NUMBER', 'DATE'],
    Field(
        ...,
        description='The type of the attribute. The type is purely informational, no validations or special formats are enforced.\nNote: The type "DATE" support is in-progress.\n',
    ),
]


type UserAttributePredefined = Annotated[
    bool,
    Field(
        ...,
        description='Signifies if the attribute is a predefined attribute that cannot be deleted and was set up by the system.\n',
    ),
]


class UserAttributeDefinitionReference(BaseModel):
    id: UserAttributeDefinitionId
    title: UserAttributeTitleTranslation
    technical_name: UserAttributeTechnicalName
    user_permission: UserAttributeUserPermission
    attribute_type: UserAttributeType
    predefined: Optional[UserAttributePredefined] = None


class AskAiTrigger(BaseModel):
    id: UUID = Field(..., description='The unique identifier of the trigger.')
    name: constr(max_length=100) = Field(..., description='The name of the trigger.')
    ai_description: constr(max_length=1000) = Field(
        ..., description='The AI description for the trigger.'
    )
    status: AskAiTriggerStatus
    actions: List[TriggerAction] = Field(
        ...,
        description='The list of actions to perform when this trigger is activated.',
    )
    created_at: CreatedAt
    updated_at: UpdatedAt


class AskAiTriggerCreateRequest(BaseModel):
    name: constr(min_length=1, max_length=100) = Field(
        ..., description='The name of the trigger.'
    )
    ai_description: constr(min_length=1, max_length=1000) = Field(
        ..., description='The AI description for the trigger.'
    )
    status: Optional[AskAiTriggerStatus] = None
    actions: List[TriggerAction] = Field(
        ...,
        description='The list of actions to perform when this trigger is activated.',
    )


class UserGroupAssignmentRuleCondition(BaseModel):
    type: UserGroupAssignmentRuleConditionType


class UserGroupAssignmentRuleUserAttributeCondition(BaseModel):
    attribute_definition_id: UserAttributeDefinitionId
    attribute_definition_reference: Optional[UserAttributeDefinitionReference] = None


type UserGroupAssignmentRuleAttributeValues = Annotated[
    List[UserGroupAssignmentRuleAttributeValue], Field(..., max_length=10, min_length=1)
]


class GenerateAssignmentRulesResponse(BaseModel):
    status: GenerateAssignmentRulesStatus


class GenerateAssignmentRulesErrorResponse(GenerateAssignmentRulesResponse):
    error_message: str = Field(
        ..., description='An error message explaining why rules could not be generated.'
    )


class AskAiTriggerSearchResult(BaseModel):
    items: List[AskAiTrigger] = Field(..., description='The list of triggers.')
    pagination: OffsetPagination


class UserGroupAssignmentRuleUserAttributeConditionAnyOf(
    UserGroupAssignmentRuleCondition, UserGroupAssignmentRuleUserAttributeCondition
):
    values: UserGroupAssignmentRuleAttributeValues


class UserGroupAssignmentRule(BaseModel):
    role_id: RoleId
    role: Optional[RoleReference] = None
    conditions: List[UserGroupAssignmentRuleUserAttributeConditionAnyOf] = Field(
        ..., min_length=1
    )


class GenerateAssignmentRulesSuccessResponse(GenerateAssignmentRulesResponse):
    rules: List[UserGroupAssignmentRule] = Field(
        ..., description='The generated assignment rules based on the prompt.'
    )
